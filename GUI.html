<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>ESP32 Geiger Pulse Monitor</title>

<style>
body {
  font-family: Helvetica, Arial, sans-serif;
  background:#f5f7fb; color:#111;
  margin:0; padding:20px;
}
.card {
  background:white; padding:20px;
  border-radius:12px; max-width:1100px;
  margin:auto; box-shadow:0 2px 6px rgba(0,0,0,0.15);
}
button {
  font-size:18px; background:#2563eb;
  color:white; padding:8px 16px;
  border:none; border-radius:8px;
  cursor:pointer; margin-right:6px;
}
button:hover { background:#1e40af; }
.data-box { font-size:22px; margin:8px 0; }

canvas {
  background:white;
  border:1px solid #ccc;
  width:100%; height:200px;
  display:block;
}

table {
  width:100%; margin-top:10px; border-collapse:collapse;
  font-size:18px;
}
th, td { border:1px solid #ccc; padding:6px; text-align:center; }

label { font-size:18px; }
</style>
</head>

<body>
<div class="card">

<h2>ESP32 Geiger Pulse Monitor</h2>

<button id="connect">Connect</button>
<button id="startBtn">Start</button>
<button id="stopBtn">Stop</button>
<button id="exportBtn">Export CSV</button>

<div class="data-box">Last Pulse Min ADC: <span id="adc">--</span></div>
<div class="data-box">Total Counts: <span id="total">0</span></div>

<label>Counts per: <span id="timeScaleLabel">Second</span></label>
<input type="range" id="timeScale" min="0" max="2" value="0">

<br><br>

<label>Threshold: <span id="thval">600</span></label>
<input type="range" id="thrSlider" min="0" max="4095" value="600" style="width:100%;">

<br><br>

<canvas id="histCanvas" width="1000" height="200"></canvas>

<table id="dataTable">
<tr>
  <th>Time (s)</th>
  <th>Total Counts</th>
  <th>Counts/Interval</th>
</tr>
</table>

</div>

<script>
let port, reader, writer;
let decoder = new TextDecoderStream();

let running = false;
let startTime = 0;
let totalCounts = 0;
let intervalCounts = 0;

// histogram bins
let bins = [];
const barWidth = 2;

// time modes
const timeLabels = ["Second","Minute","Hour"];
const msPerBin = [1000, 60000, 3600000];
let timeMode = 0;

const canvas = document.getElementById("histCanvas");
const ctx = canvas.getContext("2d");
const table = document.getElementById("dataTable");

// RESET EVERYTHING
function resetAll() {
  totalCounts = 0;
  intervalCounts = 0;
  bins = [];
  startTime = performance.now();

  document.getElementById("total").textContent = "0";

  table.innerHTML =
    `<tr>
      <th>Time (s)</th>
      <th>Total Counts</th>
      <th>Counts/Interval</th>
    </tr>`;

  drawHistogram();
}

// Draw Histogram
function drawHistogram() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(bins.length === 0) return;

  const maxVal = Math.max(...bins);
  const scale = maxVal > 0 ? canvas.height / maxVal : 1;

  for (let i = 0; i < bins.length; i++) {
    const h = bins[i] * scale;
    ctx.fillStyle = "#2563eb";
    ctx.fillRect(i * barWidth, canvas.height - h, barWidth, h);
  }
}

// Add new histogram column
function addBin(v) {
  bins.push(v);
  const maxBars = Math.floor(canvas.width / barWidth);
  if(bins.length > maxBars) bins.shift();
  drawHistogram();
}

// Put latest row at top
function addTableRow(t, total, interval) {
  const row =
    `<tr>
      <td>${t}</td>
      <td>${total}</td>
      <td>${interval}</td>
    </tr>`;

  table.innerHTML =
    table.rows[0].outerHTML + row + table.innerHTML.slice(table.rows[0].outerHTML.length);
}

// Handle ADC pulse event
function handlePulse(v) {
  if(!running) return;
  document.getElementById("adc").textContent = v;
  totalCounts++;
  intervalCounts++;
  document.getElementById("total").textContent = totalCounts;
}

// Every 1 second: process interval
setInterval(() => {
  if(!running) return;

  const elapsed = Math.floor((performance.now() - startTime) / 1000); // whole seconds
  addBin(intervalCounts);
  addTableRow(elapsed, totalCounts, intervalCounts);

  intervalCounts = 0;
}, 1000);

// Serial Reading
async function readLoop() {
  while(true){
    const {value,done} = await reader.read();
    if(done) break;
    if(!value) continue;
    const n = parseInt(value.trim());
    if(!isNaN(n)) handlePulse(n);
  }
}

// Buttons
document.getElementById("connect").onclick = async () => {
  port = await navigator.serial.requestPort();
  await port.open({baudRate:115200});
  port.readable.pipeTo(decoder.writable);
  reader = decoder.readable.getReader();
  writer = port.writable.getWriter();
  readLoop();
};

document.getElementById("startBtn").onclick = () => {
  running = true;
  resetAll();
};

document.getElementById("stopBtn").onclick = () => running = false;

// Time mode slider (label only)
document.getElementById("timeScale").oninput = e => {
  timeMode = parseInt(e.target.value);
  document.getElementById("timeScaleLabel").textContent = timeLabels[timeMode];
};

// Threshold slider â†’ send to ESP32
document.getElementById("thrSlider").oninput = e => {
  const t = e.target.value;
  document.getElementById("thval").textContent = t;
  if(writer) writer.write(new TextEncoder().encode("T"+t+"\n"));
};

// Export CSV
document.getElementById("exportBtn").onclick = () => {
  const rows = [["Time (s)","Total Counts","Counts/Interval"]];
  [...table.rows].slice(1).forEach(r=>{
    rows.push([r.cells[0].innerText, r.cells[1].innerText, r.cells[2].innerText]);
  });
  const blob = new Blob([rows.map(r=>r.join(",")).join("\n")],{type:"text/csv"});
  const url = URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url; a.download="geiger_data.csv"; a.click();
};
</script>

</body>
</html>
